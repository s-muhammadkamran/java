=====================
Model 1 Architecture:
=====================
When everything ViewLogic, Flow Logic, Queries to DB was kept inside JSPs. 
It quickly become complex

               Browser
			    /   \
			   /	 \
		     JSP1   JSP2
			   \     /  
                \   /   
               =======
              | Model |
               ======= 		

=====================
Model 2 Architecture: 
=====================
When there was separation of Control. Using Separate Model, View and Controller.
Model: Is the Data which is to generate the view
View:  Is View Logic which is your JSP
Controller: Is your Controllers


               Browser
			    /  \
			   /	\
		  Servlet1 Servlet2
             /  |  |  \
            /   |  |   \
          View1 |  |  View2
             \  |  |   /		
              \ |  |  /
               =======
              | Model |
               ======= 		

===========================================
Model 2 Architecture with Front Controller:
===========================================
Is the same as Model 2 Controller but all the controller goes to 1 Front Controller
From where it get dispatched to relevant Controller or Views.

Dispatcher Servelet is our Front Controller.

               Browser
			      | 
			      |
           Front Controller
		   =================
		  /     |     |     \
         /      |     |      \
	Servlet1  View1  View2  Servlet2
         \      |     |      /
          \     |     |     / 
     	   =================
          |      Model      |
           =================

		   
===================
Dispatcher Servlet:
===================
Dispatcher Servlet is the Model 2 Front Controller implementation.
All the request to any views or Controller will be received by Dispatcher Servlet.
Dispatcher Servlet is then dispatches the request to the appropriate controller.
All the Controller and View have access to Model.
Following is how it works:

0. A request is made from Browser.
   http://localhost:8080/login
   
1. Dispatcher Servlet receives requests
2. It then identify the right controller and execute it.
   /login => LoginController.login
   
3. Controller will return the Model and View to Dispatcher Servlet.
   Controller => Puts data into model
   Controller => Return view name => login
   
4. Dispatcher Servlet is then talk to the ViewResolver and get the View Name.
   ViewResolver => /WEB-INF/jsp/login.jsp
   
5. It then make the model available to the view.
6. View is then processed and return the response to the browser





==========================================
Build a Web Application using Spring Boot:
==========================================
To build a Web Application, Generate the project from http://start.spring.io/
Add the dependency for the following
Web (Supports for MVC, embeded tomcat, WebServices etc)
DevTools (provides runtime development support tools)
JASPER  (For Forwarding request from Web Controller to JSP pages)

Add the following configuration in application.config

server.port=8080 //To start the tomcat server on port 8080 which is default in application.properties.
logging.level.org.springframework=DEBUG

================
Some Annotation:
================

@Controller: As @RestController declares a Rest Controller, Similarly @Controller declares a Web Controller.

@RequestMapping("path"): Maps a method to the URL path.
It can have multiple parameters like 
value {}: More than one path can be defined
headers{}: The required headers to be present when making a request
method{}: {RequestMethod.Post and/or RequestMethod.Get}: Get is the default value

@RequestMapping(
  value={"/sayhello", "say-hello", "/sayhello/{name}, *"}, method={RequestMethod.Post, RequestMethod.Get},
  headers={"name=kamran", "pass=123"}, produces={"application/json", "application/xml"},
  consumes="text/html"
)
@ResponseBody
public String sayHello(@RequestParam("name") String name) {
  name = name == null || name.isEmpty() ? "Stranger" : name.trim();
  return "Hello "+name+"! what are you learning today?";
}

@ResponseBody: Annotation bind the Http response body with a domain object in the return type.

@Controller
public class SayHelloController {
    @RequestMapping(value = {"say-hello", "sayhello", "*"})
    @ResponseBody
    public String sayHello(@RequestParam("name") String name) {
        name = name == null || name.isEmpty() ? "Stranger" : name.trim();
        return "Hello "+name+"! what are you learning today?";
    }
}

======
Views:
======
Web Controller instead of returning HTML and other objects can redirect users to what is called as Views
The most famous type of views used are called JSP
JSP = Java or Jakarta Server Pages
You save these views in the following location:
/src/main/resources/META-INF/resources/[WEB-INF/jsp/]

You can inform about the path of JSPs to spring controller using the application.properties file
Save the following 2 configuration in the properties file

spring.mvc.view.prefix=/WEB-INF/jsp/
spring.mvc.view.suffix=.jsp

It already knows the path until /src/main/resources/META-INF/resources/
You need to inform it the path after that.
And the method just return the fileName part of the views.
The names of path and file are case sensitive

@RequestMapping(value={"say-hello-jsp", "sayhellojsp"})
// \src\main\resources\META-INF\resources\WEB-INF\jsp\sayHello.jsp
// You can keep the Prefix.Suffix format in application.properties file
// prefix=/WEB-INF/jsp
// suffix=.jsp
public String sayHelloJsp() {
	return "sayHelloInJsp";
}

In order for it to work, you need to add the JSP dependency for JASPER in pom.xml
It'll allow you to run JSP's from embed Tomcat
<dependency>
	<groupId>org.apache.tomcat.embed</groupId>
	<artifactId>tomcat-embed-jasper</artifactId>
</dependency>

======
Model:
======
You can pass values to your JSP using something called ModelMap
ModelMap is injected in your code and you just need to call the method:
ModelMapObj.put("name", name)
What ever you pass here, it'll be available in your JSP with the name
you provided as the first parameters
public String login(@RequestParam String name, ModelMap model) {
	model.put("name", name);
	return "login";	
}

You can use this in the JSP using the expression language ${name} tag.

Logging Factory:
================
If you want custom logging in your application you can request a logger from 
LoggerFactory.getLogger(getClass()); method.
It will create a logger using Your Class, and you can easily filter your logs

Logger logger = LoggerFactory.getLogger(getClass());

